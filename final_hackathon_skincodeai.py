# -*- coding: utf-8 -*-
"""FINAL_Hackathon_SkincodeAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pSBlJHrjPKnzb2vX3W7YVTEh4OKwimlV

## Requerimientos
"""

# Librerias
# IA generativa google
import google.generativeai as genai

# Install the missing library
!pip install python-telegram-bot

# Telegram
import asyncio
import nest_asyncio
import logging
import google.generativeai as genai
from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    MessageHandler,
    filters,
    ContextTypes,
)

import pandas as pd
import google.generativeai as genai
from PIL import Image
import os
import random
import matplotlib.pyplot as plt
import kagglehub



# Download latest version
path = kagglehub.dataset_download("mexwell/bivtatt-dataset")

print("Path to dataset files:", path)

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

"""Procesamiento Base DATOS"""

# Librerias
# IA generativa google
import google.generativeai as genai

# Telegram
import asyncio
import nest_asyncio
import logging
import google.generativeai as genai
from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    MessageHandler,
    filters,
    ContextTypes,
)

import pandas as pd
import google.generativeai as genai
from PIL import Image
import os
import random
import matplotlib.pyplot as plt
import kagglehub

# Download latest version
path = kagglehub.dataset_download("mexwell/bivtatt-dataset")

print("Path to dataset files:", path)

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Define the path to the Excel file
excel_path = '/content/drive/MyDrive/BaseDatos_Pruebas/DB_Imagen.xlsx'

# Check if the file exists
if not os.path.exists(excel_path):
    print(f"Error: Excel file not found at {excel_path}")
else:
    try:
        # Read the Excel file into a pandas DataFrame
        description_df = pd.read_excel(excel_path)

        # Display the first few rows of the DataFrame to verify
        print("Successfully loaded the Excel file.")

    except Exception as e:
        print(f"Error reading the Excel file: {e}")

# Remove the first column (Unnamed: 0)
description_df = description_df.drop(columns=['Unnamed: 0'])

# Set the first row as the header
description_df.columns = description_df.iloc[0]

# Remove the first row which is now the header
description_df = description_df[1:].reset_index(drop=True)

# --- Modification: Clean 'nombre_imagen' column ---
# Remove text after 'G' (including 'G')
description_df['nombre_imagen'] = description_df['nombre_imagen'].astype(str).apply(lambda x: x.split('G', 1)[0] + 'G' if 'G' in x else x)
# Remove text after 'g' (including 'g')
description_df['nombre_imagen'] = description_df['nombre_imagen'].astype(str).apply(lambda x: x.split('g', 1)[0] + 'g' if 'g' in x else x)


# Display the updated DataFrame
print("Updated DataFrame after removing the first column, setting the first row as header, and cleaning 'nombre_imagen':")
display(description_df)

print("Column headers of description_df:")
print(description_df.columns.tolist())

"""## APP (Testeo-Telegram)"""

# PRUEBA IMAGEN EXITOSA ======================================
# ğŸ§© INSTALACIÃ“N DE DEPENDENCIAS
# ======================================
!pip install python-telegram-bot --upgrade > /dev/null
!pip install google-generativeai nest_asyncio > /dev/null

# ======================================
# ğŸ“¦ IMPORTS
# ======================================
import asyncio
import logging
import nest_asyncio
from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
)
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder, ContextTypes, CommandHandler,
    CallbackQueryHandler, ConversationHandler, MessageHandler, filters
)
import google.generativeai as genai
import os
from PIL import Image
import matplotlib.pyplot as plt

# ======================================
# âš™ï¸ CONFIGURACIÃ“N INICIAL
# ======================================
nest_asyncio.apply()
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)

# ======================================
# ğŸ”‘ CREDENCIALES
# ======================================
API_TOKEN = '7998261719:AAH2u1-70QsPCU8o6735SCijf17dtafXemw'
GEMINI_API_KEY = 'AIzaSyBKyPHDv8D69C6UZOodOAD3NJ3L9CJolig'#'AIzaSyDTgHLBYHULltT0o6vGiMjswYoc2dNWRdk' #'AIzaSyD6nUb7y0f-EiT53BMyfRH3FXCMB1drkW4'

genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel("gemini-2.5-flash")

# ======================================
# ğŸ’¬ ESTADOS DE CONVERSACIÃ“N (Actualizado)
# ======================================
EXISTENCIA, MOTIVO, CATEGORIA_TATUAJE, ESTILO, TEMATICA, UBICACION, ATRIBUTOS_CLAVES, IA, EMAIL, PHONE, CONTACTO = range(11)

# ======================================
# ğŸ¤– ESTADO IA - GENERACIÃ“N DE IMÃGENES Y DESCRIPCIÃ“N
# ======================================
async def ia_generation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # Mostrar mensaje de procesamiento
    await query.edit_message_text(
        "ğŸ”„ *Generando recomendaciones personalizadas con IA...*\n\n"
        "Estamos creando ideas Ãºnicas basadas en tus preferencias. Esto tomarÃ¡ unos segundos...",
        parse_mode=ParseMode.MARKDOWN
    )

    try:
        # Configurar Gemini
        genai.configure(api_key=GEMINI_API_KEY)
        model = genai.GenerativeModel('gemini-2.5-flash')

        # ======================================
        # ğŸ–¼ï¸ SELECCIÃ“N Y ENVÃO DE IMAGEN ALEATORIA
        # ======================================

        # Buscar todas las imÃ¡genes en el dataset
        image_extensions = ['.jpg', '.jpeg', '.png', '.bmp', '.gif']
        image_files = []

        for root, dirs, files in os.walk(path):
            for file in files:
                if any(file.lower().endswith(ext) for ext in image_extensions):
                    image_files.append(os.path.join(root, file))

        if image_files:
            # Seleccionar imagen aleatoria
            selected_image_path = random.choice(image_files)

            # Enviar la imagen al usuario
            with open(selected_image_path, 'rb') as img_file:
                await context.bot.send_photo(
                    chat_id=update.effective_chat.id,
                    photo=InputFile(img_file),
                    caption="ğŸ¨ *Imagen de referencia seleccionada para ti*\n\n"
                           "Esta imagen ha sido elegida basada en tus preferencias. "
                           "A continuaciÃ³n analizaremos sus caracterÃ­sticas...",
                    parse_mode=ParseMode.MARKDOWN
                )

            # Guardar la ruta de la imagen en user_data para referencia
            context.user_data['selected_image_path'] = selected_image_path

        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="âš ï¸ *No se encontraron imÃ¡genes en el dataset*",
                parse_mode=ParseMode.MARKDOWN
            )

        # ======================================
        # ğŸ¤– GENERACIÃ“N DE ANÃLISIS CON GEMINI
        # ======================================

        # Construir descripciÃ³n del tatuaje basado en los datos del usuario
        user_data = context.user_data
        tattoo_description = (
            f"CategorÃ­a: {user_data.get('categoria_tatuaje', 'No especificada')}, "
            f"Estilo: {user_data.get('estilo', 'No especificado')}, "
            f"TemÃ¡tica: {user_data.get('tematica', 'No especificada')}, "
            f"UbicaciÃ³n: {user_data.get('ubicacion', 'No especificada')}, "
            f"TamaÃ±o: {user_data.get('atributos_claves', 'No especificado')}"
        )

        # Generar contenido con Gemini
        prompt = f"""
                  <Rol>Eres un ANALISTA ESPECIALIZADO EN IDENTIFICACIÃ“N DE ESTILOS DE TATUAJE.
                  Tu Ãºnica funciÃ³n es analizar tattoos y categorizar exactamente su estilo
                  y otras caracteristicas relacionadas al tatuaje.<Rol>

                  <Analisis>
                  1. IDENTIFICAR TEMA PRINCIPAL:
                  - Breve descripciÃ³n de la imagen
                  - Parte del cuerpo que se encuentra en la imagen

                  2. ANALIZAR CARACTERÃSTICAS VISUALES:
                  - Paleta de colores (Color o Blanco y Negro)
                  - Grosor de lÃ­neas
                  - Tipo de sombreado
                  - Nivel de detalle

                  3. CLASIFICAR ESTILO:
                  - Estilo principal (80% del diseÃ±o entre:Realismo, Tribal, Minimalista, old School,GeomÃ©trico)
                  - Influencias secundarias
                  - TÃ©cnicas mixtas si aplica

                  4. RECOMENDACIONES:
                  - Explicar porque es una buena opcion realizarce ese tatuaje, para hombre y para mujer
                  - Realizar un precio estimando segun {description_df}
                  <Analisis>

                  <Reglas>
                  - Explicar todo en espaÃ±ol
                  - Ser claro y conciso
                  - Incluir emojis relevantes
                  - MÃ¡ximo 500 palabras
                  <Reglas>

                  <Preferencias del usuario>
                  estas son las Preferencias del uruario {tattoo_description} encontrar  {description_df}
                  <Preferencias del usuario>
                  """

        response = model.generate_content(prompt)

        # Enviar recomendaciones al usuario
        recommendations = response.text

        # Dividir el mensaje si es muy largo (lÃ­mite de Telegram: 4096 caracteres)
        if len(recommendations) > 4000:
            parts = [recommendations[i:i+4000] for i in range(0, len(recommendations), 4000)]
            for part in parts:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=part,
                    parse_mode=ParseMode.MARKDOWN
                )
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=recommendations,
                parse_mode=ParseMode.MARKDOWN
            )

        # Guardar las recomendaciones en user_data para referencia
        context.user_data['ia_recommendations'] = recommendations

        # Continuar con el flujo pidiendo el email
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="âœ¨ *Â¡Recomendaciones generadas!*\n\n"
                 "Si deseas que uno de nuestros artistas te contacte para discutir estas ideas, "
                 "por favor ingresa tu *correo electrÃ³nico*:",
            parse_mode=ParseMode.MARKDOWN
        )

        return EMAIL

    except Exception as e:
        print(f"Error en IA: {e}")

        # En caso de error, continuar con el flujo normal
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="âš ï¸ *No pudimos generar recomendaciones en este momento, pero podemos continuar.*\n\n"
                 "Si deseas que uno de nuestros artistas te contacte, "
                 "por favor ingresa tu *correo electrÃ³nico*:",
            parse_mode=ParseMode.MARKDOWN
        )
        return EMAIL

# ======================================
# ğŸ”™ FUNCIÃ“N PARA RETROCEDER
# ======================================
async def back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # Get the previous state from the history
    if 'history' in context.user_data and len(context.user_data['history']) > 1:
        context.user_data['history'].pop()  # Remove current state
        previous_state = context.user_data['history'][-1] # Get previous state

        # Resend the message for the previous state
        if previous_state == EXISTENCIA:
            await start(update, context)
            return EXISTENCIA
        elif previous_state == MOTIVO:
            keyboard = [
                [InlineKeyboardButton("ğŸ–‹ï¸ Nuevo Tatuaje", callback_data="nuevo_tatuaje")],
                [InlineKeyboardButton("ğŸ©¹ CorrecciÃ³n de Tatuaje", callback_data="correccion_tatuaje")],
                [InlineKeyboardButton("ğŸ“ Cursos", callback_data="cursos")],
                [InlineKeyboardButton("ğŸ‰ Eventos", callback_data="eventos")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "Gracias. Â¿CuÃ¡l es el *motivo* de tu visita hoy?",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return MOTIVO
        elif previous_state == CATEGORIA_TATUAJE:
            keyboard = [
                [InlineKeyboardButton("1ï¸âƒ£ Realista", callback_data="realista")],
                [InlineKeyboardButton("2ï¸âƒ£ Minimalista", callback_data="minimalista")],
                [InlineKeyboardButton("3ï¸âƒ£ Tradicional", callback_data="tradicional")],
                [InlineKeyboardButton("4ï¸âƒ£ Lettering", callback_data="lettering")],
                [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "Perfecto ğŸ˜ Â¡Vamos a crear algo increÃ­ble juntos!\n\n"
                "Selecciona la *categorÃ­a* del tatuaje que te gustarÃ­a realizarte:",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return CATEGORIA_TATUAJE
        elif previous_state == ESTILO:
            keyboard = [
                [InlineKeyboardButton("âš« Sombras", callback_data="sombras")],
                [InlineKeyboardButton("ã€°ï¸ LÃ­neas", callback_data="lineas")],
                [InlineKeyboardButton("oth Otros", callback_data="otros_estilo")],
                [InlineKeyboardButton("â“ No sÃ©", callback_data="no_se_estilo")],
                [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                f"Excelente elecciÃ³n ğŸ˜ Has elegido un tatuaje de la categorÃ­a *{context.user_data.get('categoria_tatuaje', 'No especificada')}*.\n\n"
                "Â¿QuÃ© *estilo* de sombras o lÃ­neas prefieres?", # Added text option
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return ESTILO
        elif previous_state == TEMATICA:
            keyboard = [
                [InlineKeyboardButton("ğŸ¦ Animales", callback_data="animales")],
                [InlineKeyboardButton("ğŸŒ³ Naturaleza", callback_data="naturaleza")],
                [InlineKeyboardButton("âš›ï¸ SÃ­mbolos", callback_data="simbolos")],
                [InlineKeyboardButton("â“ No sÃ©", callback_data="no_se_tematica")],
                [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                f"Perfecto ğŸ‘Œ Has seleccionado el estilo *{context.user_data.get('estilo', 'No especificado')}*.\n\n"
                "Â¿CuÃ¡l *temÃ¡tica* te gustarÃ­a para tu tatuaje?\n\n_(O puedes escribir tu preferencia)_",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return TEMATICA
        elif previous_state == UBICACION:
            await query.edit_message_text(
                f"Interesante! Has elegido la temÃ¡tica *{context.user_data.get('tematica', 'No especificada')}*.\n\n"
                "Â¿En quÃ© parte del cuerpo te gustarÃ­a hacerlo? (Por ejemplo: brazo, pierna, espalda, etc.)\n\n"
                "_(Responde con texto)_"
            )
            return UBICACION
        elif previous_state == ATRIBUTOS_CLAVES:
            keyboard = [
                [InlineKeyboardButton("ğŸ“ PequeÃ±o", callback_data="pequeno")],
                [InlineKeyboardButton("ğŸ“ Mediano", callback_data="mediano")],
                [InlineKeyboardButton("ğŸ–¼ï¸ Grande", callback_data="grande")],
                [InlineKeyboardButton("â“ No sÃ©", callback_data="no_se_tamano")],
                [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                f"UbicaciÃ³n registrada: *{context.user_data.get('ubicacion', 'No especificada')}* ğŸ“\n\n"
                "Genial ğŸ’ª Â¿QuÃ© *tamaÃ±o* prefieres para tu tatuaje?",
                 parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return ATRIBUTOS_CLAVES
        elif previous_state == IA:
            keyboard = [
                [InlineKeyboardButton("ğŸ¤– SÃ­, generar recomendaciones IA", callback_data="si_ia")],
                [InlineKeyboardButton("â­ï¸ Saltar al contacto", callback_data="no_ia")],
                [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "ğŸ¨ *Â¿Te gustarÃ­a recibir recomendaciones personalizadas con IA?*\n\n"
                "Nuestra inteligencia artificial puede generar ideas Ãºnicas basadas en tus preferencias "
                "y proporcionar estimados de precio y tiempo.",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return IA
        elif previous_state == EMAIL:
            await query.edit_message_text(
                "âœ¨ *Â¡Recomendaciones generadas!* (o saltaste la IA)\n\n"
                "Si deseas que uno de nuestros artistas te contacte para discutir estas ideas, "
                "por favor ingresa tu *correo electrÃ³nico*:",
                parse_mode=ParseMode.MARKDOWN
            )
            return EMAIL
        elif previous_state == PHONE:
            await query.edit_message_text(
                "Gracias. Ahora, por favor, comparte tu *nÃºmero de telÃ©fono*:",
                parse_mode=ParseMode.MARKDOWN
            )
            return PHONE

    # If no history or only one state in history, stay in the current state
    return context.user_data.get('history', [EXISTENCIA])[-1]


# ======================================
# ğŸ INICIO /START
# ======================================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Clear user data on new start and initialize history
    context.user_data.clear()
    context.user_data['history'] = [EXISTENCIA] # Initialize history

    keyboard = [
        [InlineKeyboardButton("âœ… Ya he visitado Find Ink", callback_data="existente")],
        [InlineKeyboardButton("ğŸ†• Soy nuevo en Find Ink", callback_data="nuevo")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "Â¡Hola ğŸ‘‹! Bienvenido(a) a *Find Ink Tattoo Studio* ğŸ¨\n\n"
        "Â¿Ya has visitado nuestro estudio antes o eres nuevo(a)?",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )

    return EXISTENCIA

# FunciÃ³n separada para manejar las opciones del botÃ³n
async def handle_option(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    opcion = query.data

    if opcion == "nuevo":
        # AquÃ­ puedes agregar la lÃ³gica para usuarios nuevos
        await query.edit_message_text(
            "Â¡Bienvenido nuevo usuario! Estamos encantados de tenerte en Find Ink Tattoo Studio ğŸ¨\n\n"
            "Â¿En quÃ© podemos ayudarte hoy?",
            parse_mode=ParseMode.MARKDOWN
        )
        return ConversationHandler.END

    elif opcion == "existente":
        await query.edit_message_text(
            "ğŸ“ *Cursos Find Ink*\n\n"
            "Â¡Excelente elecciÃ³n! ğŸ˜ Ofrecemos cursos profesionales para artistas del tatuaje.\n\n"
            "ğŸ‘‰ Instagram: https://www.instagram.com/findink.co/\n"
            "ğŸ‘‰ skincode: https://uncognoscible-paler-nicola.ngrok-free.dev/"
            "ğŸ‘‰ Linktree: https://linktr.ee/findink.co",
            parse_mode=ParseMode.MARKDOWN
        )
        return ConversationHandler.END


# ======================================
# ğŸ’¬ EXISTENCIA DEL USUARIO
# ======================================
async def existencia(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    context.user_data["existencia"] = query.data
    context.user_data['history'].append(MOTIVO) # Add to history

    keyboard = [
        [InlineKeyboardButton("ğŸ–‹ï¸ Nuevo Tatuaje", callback_data="nuevo_tatuaje")],
        [InlineKeyboardButton("ğŸ©¹ CorrecciÃ³n de Tatuaje", callback_data="correccion_tatuaje")],
        [InlineKeyboardButton("ğŸ“ Cursos", callback_data="cursos")],
        [InlineKeyboardButton("ğŸ‰ Eventos", callback_data="eventos")],
        # No back button on the first step
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        "Gracias. Â¿CuÃ¡l es el *motivo* de tu visita hoy?",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    return MOTIVO

# ======================================
# ğŸ’¬ MOTIVO DE VISITA
# ======================================
async def motivo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    opcion = query.data
    context.user_data["motivo"] = opcion
    context.user_data['history'].append(CATEGORIA_TATUAJE) # Add to history

    if opcion == "nuevo_tatuaje" or opcion == "correccion_tatuaje":
        keyboard = [
            [InlineKeyboardButton("1ï¸âƒ£ Realista", callback_data="realista")],
            [InlineKeyboardButton("2ï¸âƒ£ Minimalista", callback_data="minimalista")],
            [InlineKeyboardButton("3ï¸âƒ£ Tradicional", callback_data="tradicional")],
            [InlineKeyboardButton("4ï¸âƒ£ Lettering", callback_data="lettering")],
            [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "Perfecto ğŸ˜ Â¡Vamos a crear algo increÃ­ble juntos!\n\n"
            "Selecciona la *categorÃ­a* del tatuaje que te gustarÃ­a realizarte:",
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
        return CATEGORIA_TATUAJE

    elif opcion == "cursos":
        await query.edit_message_text(
            "ğŸ“ *Cursos Find Ink*\n\n"
            "Â¡Excelente elecciÃ³n! ğŸ˜ Ofrecemos cursos profesionales para artistas del tatuaje.\n\n"
            "ğŸ‘‰ Instagram: https://www.instagram.com/findink.co/\n"
            "ğŸ‘‰ skincode: https://uncognoscible-paler-nicola.ngrok-free.dev/"
            "ğŸ‘‰ Linktree: https://linktr.ee/findink.co",
            parse_mode=ParseMode.MARKDOWN
        )
        return ConversationHandler.END


    elif opcion == "eventos":
        await query.edit_message_text(
            "ğŸ‰ *Eventos Find Ink*\n\n"
            "Â¡Genial! ğŸŠ Nos encanta compartir el arte del tatuaje con la comunidad.\n\n"
            "ğŸ‘‰ PrÃ³ximos eventos:\n"
            "ğŸ”— https://linktr.ee/findink.co",
            parse_mode=ParseMode.MARKDOWN
        )
        return ConversationHandler.END

# ======================================
# ğŸ¨ CATEGORIA DEL TATUAJE
# ======================================
async def categoria_tatuaje(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    categoria_tat = query.data
    context.user_data["categoria_tatuaje"] = categoria_tat
    context.user_data['history'].append(ESTILO) # Add to history

    keyboard = [
        [InlineKeyboardButton("âš« Sombras", callback_data="sombras")],
        [InlineKeyboardButton("ã€°ï¸ LÃ­neas", callback_data="lineas")],
        [InlineKeyboardButton("â“ No sÃ©", callback_data="no_se_estilo")],
        [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        f"Excelente elecciÃ³n ğŸ˜ Has elegido un tatuaje de la categorÃ­a *{categoria_tat}*.\n\n"
        "Â¿QuÃ© *estilo* de sombras o lÃ­neas prefieres?\n\n_(O puedes escribir tu preferencia)_", # Added text option
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    return ESTILO

# ======================================
# ğŸ–¼ï¸ ESTILO DEL TATUAJE (MODIFIED)
# ======================================
async def estilo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Check if it's a callback query (button click) or a text message
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        estilo_tat = query.data
        message_to_edit = query.edit_message_text
    elif update.message:
        estilo_tat = update.message.text
        message_to_edit = update.message.reply_text # Use reply_text for text messages
    else:
        # Should not happen, but handle if needed
        return ESTILO # Stay in the same state if input is neither callback nor text

    context.user_data["estilo"] = estilo_tat
    context.user_data['history'].append(TEMATICA) # Add to history

    keyboard = [
        [InlineKeyboardButton("ğŸ¦ Animales", callback_data="animales")],
        [InlineKeyboardButton("ğŸŒ³ Naturaleza", callback_data="naturaleza")],
        [InlineKeyboardButton("âš›ï¸ SÃ­mbolos", callback_data="simbolos")],
        [InlineKeyboardButton("â“ No sÃ©", callback_data="no_se_tematica")],
        [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await message_to_edit( # Use the appropriate method (edit_message_text or reply_text)
        f"Perfecto ğŸ‘Œ Has seleccionado el estilo *{estilo_tat}*.\n\n"
        "Â¿CuÃ¡l *temÃ¡tica* te gustarÃ­a para tu tatuaje?\n\n_(O puedes escribir tu preferencia)_", # Added text option
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    return TEMATICA

# ======================================
# ğŸŒ¿ TEMATICA DEL TATUAJE (MODIFIED)
# ======================================
async def tematica(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Check if it's a callback query (button click) or a text message
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        tematica_tat = query.data
        message_to_edit = query.edit_message_text
    elif update.message:
        tematica_tat = update.message.text
        message_to_edit = update.message.reply_text # Use reply_text for text messages
    else:
        # Should not happen, but handle if needed
        return TEMATICA # Stay in the same state if input is neither callback nor text

    context.user_data["tematica"] = tematica_tat
    context.user_data['history'].append(UBICACION) # Add to history

    await message_to_edit( # Use the appropriate method (edit_message_text or reply_text)
        f"Interesante! Has elegido la temÃ¡tica *{tematica_tat}*.\n\n"
        "Â¿En quÃ© parte del cuerpo te gustarÃ­a hacerlo? (Por ejemplo: brazo, pierna, espalda, etc.)\n\n"
        "_(Responde con texto)_"
    )
    return UBICACION

# ======================================
# ğŸ“ UBICACIÃ“N DEL TATUAJE
# ======================================
async def ubicacion(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["ubicacion"] = update.message.text
    context.user_data['history'].append(ATRIBUTOS_CLAVES) # Add to history

    keyboard = [
        [InlineKeyboardButton("ğŸ“ PequeÃ±o", callback_data="pequeno")],
        [InlineKeyboardButton("ğŸ“ Mediano", callback_data="mediano")],
        [InlineKeyboardButton("ğŸ–¼ï¸ Grande", callback_data="grande")],
        [InlineKeyboardButton("â“ No sÃ©", callback_data="no_se_tamano")],
        [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "Genial ğŸ’ª Â¿QuÃ© *tamaÃ±o* prefieres para tu tatuaje?",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN
    )
    return ATRIBUTOS_CLAVES

# ======================================
# ğŸ“ ATRIBUTOS CLAVES (Modificado para llamar a IA)
# ======================================
async def atributos_claves(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    context.user_data["atributos_claves"] = query.data
    context.user_data['history'].append(IA) # Add to history

    # Preguntar si quiere recomendaciones de IA
    keyboard = [
        [InlineKeyboardButton("ğŸ¤– SÃ­, generar recomendaciones IA", callback_data="si_ia")],
        [InlineKeyboardButton("â­ï¸ Saltar al contacto", callback_data="no_ia")],
        [InlineKeyboardButton("ğŸ”™ AtrÃ¡s", callback_data="back")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        "ğŸ¨ *Â¿Te gustarÃ­a recibir recomendaciones personalizadas con IA?*\n\n"
        "Nuestra inteligencia artificial puede generar ideas Ãºnicas basadas en tus preferencias "
        "y proporcionar estimados de precio y tiempo.",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    return IA

# ======================================
# ğŸ¤– MANEJADOR DE OPCIONES IA
# ======================================
async def handle_ia_option(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    opcion = query.data

    if opcion == "si_ia":
        context.user_data['history'].append(EMAIL) # Add to history
        # Ir al estado de generaciÃ³n IA
        return await ia_generation(update, context)
    elif opcion == "no_ia":
        context.user_data['history'].append(EMAIL) # Add to history
        # Saltar directamente a email
        await query.edit_message_text(
            "ğŸ‘Œ Continuemos. Por favor, ingresa tu *correo electrÃ³nico* "
            "para que nuestros artistas te contacten:",
            parse_mode=ParseMode.MARKDOWN
        )
        return EMAIL


# ======================================
# ğŸ“§ RECEPCIÃ“N DE CORREO ELECTRÃ“NICO
# ======================================
async def email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['email'] = update.message.text
    context.user_data['history'].append(PHONE) # Add to history

    await update.message.reply_text(
        "Gracias. Ahora, por favor, comparte tu *nÃºmero de telÃ©fono*:",
        parse_mode=ParseMode.MARKDOWN
    )
    return PHONE # Transition to PHONE state

# ======================================
# ğŸ“± RECEPCIÃ“N DE NÃšMERO DE TELÃ‰FONO
# ======================================
async def phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['phone'] = update.message.text
    context.user_data['history'].append(CONTACTO) # Add to history


    # Now transition to the final CONTACTO state
    await update.message.reply_text(
        "Â¡Perfecto! Tus datos han sido registrados. ğŸ‰\n\n"
        "Pronto nos pondremos en contacto contigo para continuar con tu proceso.\n\n"
        "Gracias por confiar en *Find Ink Tattoo Studio* ğŸ’€ğŸ¨",
        parse_mode=ParseMode.MARKDOWN
    )
    print("ğŸ—‚ï¸ Datos del cliente:", context.user_data)
    return ConversationHandler.END # End the conversation

async def main():
    app = ApplicationBuilder().token(API_TOKEN).build()

    flujo = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            EXISTENCIA: [CallbackQueryHandler(existencia)],
            MOTIVO: [CallbackQueryHandler(motivo)],
            CATEGORIA_TATUAJE: [CallbackQueryHandler(categoria_tatuaje)],
            ESTILO: [
                CallbackQueryHandler(estilo),
                MessageHandler(filters.TEXT & ~filters.COMMAND, estilo) # Added text handler
            ],
            TEMATICA: [
                CallbackQueryHandler(tematica),
                MessageHandler(filters.TEXT & ~filters.COMMAND, tematica) # Added text handler
            ],
            UBICACION: [MessageHandler(filters.TEXT & ~filters.COMMAND, ubicacion)],
            ATRIBUTOS_CLAVES: [CallbackQueryHandler(atributos_claves)],
            IA: [CallbackQueryHandler(handle_ia_option)],  # Nuevo estado
            EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, email)],
            PHONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, phone)],
            CONTACTO: [CallbackQueryHandler(handle_option)],
        },
        fallbacks=[CallbackQueryHandler(back, pattern='^back$')], # Add fallback for 'back'
    )

    app.add_handler(flujo)
    print("âœ… Bot iniciado. Esperando mensajes...")
    await app.run_polling(poll_interval=3.0)

# ======================================
# ğŸ EJECUCIÃ“N
# ======================================
try:
    asyncio.run(main())
except RuntimeError:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())