# -*- coding: utf-8 -*-
"""FINAL_Hackathon_SkincodeAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pSBlJHrjPKnzb2vX3W7YVTEh4OKwimlV

## Requerimientos
"""

# Librerias
# IA generativa google
import google.generativeai as genai

# Install the missing library
!pip install python-telegram-bot

# Telegram
import asyncio
import nest_asyncio
import logging
import google.generativeai as genai
from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    MessageHandler,
    filters,
    ContextTypes,
)

import pandas as pd
import google.generativeai as genai
from PIL import Image
import os
import random
import matplotlib.pyplot as plt
import kagglehub



# Download latest version
path = kagglehub.dataset_download("mexwell/bivtatt-dataset")

print("Path to dataset files:", path)

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

"""Procesamiento Base DATOS"""

# Librerias
# IA generativa google
import google.generativeai as genai

# Telegram
import asyncio
import nest_asyncio
import logging
import google.generativeai as genai
from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    MessageHandler,
    filters,
    ContextTypes,
)

import pandas as pd
import google.generativeai as genai
from PIL import Image
import os
import random
import matplotlib.pyplot as plt
import kagglehub

# Download latest version
path = kagglehub.dataset_download("mexwell/bivtatt-dataset")

print("Path to dataset files:", path)

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Define the path to the Excel file
excel_path = '/content/drive/MyDrive/BaseDatos_Pruebas/DB_Imagen.xlsx'

# Check if the file exists
if not os.path.exists(excel_path):
    print(f"Error: Excel file not found at {excel_path}")
else:
    try:
        # Read the Excel file into a pandas DataFrame
        description_df = pd.read_excel(excel_path)

        # Display the first few rows of the DataFrame to verify
        print("Successfully loaded the Excel file.")

    except Exception as e:
        print(f"Error reading the Excel file: {e}")

# Remove the first column (Unnamed: 0)
description_df = description_df.drop(columns=['Unnamed: 0'])

# Set the first row as the header
description_df.columns = description_df.iloc[0]

# Remove the first row which is now the header
description_df = description_df[1:].reset_index(drop=True)

# --- Modification: Clean 'nombre_imagen' column ---
# Remove text after 'G' (including 'G')
description_df['nombre_imagen'] = description_df['nombre_imagen'].astype(str).apply(lambda x: x.split('G', 1)[0] + 'G' if 'G' in x else x)
# Remove text after 'g' (including 'g')
description_df['nombre_imagen'] = description_df['nombre_imagen'].astype(str).apply(lambda x: x.split('g', 1)[0] + 'g' if 'g' in x else x)


# Display the updated DataFrame
print("Updated DataFrame after removing the first column, setting the first row as header, and cleaning 'nombre_imagen':")
display(description_df)

print("Column headers of description_df:")
print(description_df.columns.tolist())

"""## APP (Testeo-Telegram)"""

# PRUEBA IMAGEN EXITOSA ======================================
# üß© INSTALACI√ìN DE DEPENDENCIAS
# ======================================
!pip install python-telegram-bot --upgrade > /dev/null
!pip install google-generativeai nest_asyncio > /dev/null

# ======================================
# üì¶ IMPORTS
# ======================================
import asyncio
import logging
import nest_asyncio
from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
)
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder, ContextTypes, CommandHandler,
    CallbackQueryHandler, ConversationHandler, MessageHandler, filters
)
import google.generativeai as genai
import os
from PIL import Image
import matplotlib.pyplot as plt

# ======================================
# ‚öôÔ∏è CONFIGURACI√ìN INICIAL
# ======================================
nest_asyncio.apply()
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)

# ======================================
# üîë CREDENCIALES
# ======================================
API_TOKEN = '7998261719:AAH2u1-70QsPCU8o6735SCijf17dtafXemw'
GEMINI_API_KEY = 'AIzaSyBKyPHDv8D69C6UZOodOAD3NJ3L9CJolig'#'AIzaSyDTgHLBYHULltT0o6vGiMjswYoc2dNWRdk' #'AIzaSyD6nUb7y0f-EiT53BMyfRH3FXCMB1drkW4'

genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel("gemini-2.5-flash")

# ======================================
# üí¨ ESTADOS DE CONVERSACI√ìN (Actualizado)
# ======================================
EXISTENCIA, MOTIVO, CATEGORIA_TATUAJE, ESTILO, TEMATICA, UBICACION, ATRIBUTOS_CLAVES, IA, EMAIL, PHONE, CONTACTO = range(11)

# ======================================
# ü§ñ ESTADO IA - GENERACI√ìN DE IM√ÅGENES Y DESCRIPCI√ìN
# ======================================
async def ia_generation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # Mostrar mensaje de procesamiento
    await query.edit_message_text(
        "üîÑ *Generando recomendaciones personalizadas con IA...*\n\n"
        "Estamos creando ideas √∫nicas basadas en tus preferencias. Esto tomar√° unos segundos...",
        parse_mode=ParseMode.MARKDOWN
    )

    try:
        # Configurar Gemini
        genai.configure(api_key=GEMINI_API_KEY)
        model = genai.GenerativeModel('gemini-2.5-flash')

        # ======================================
        # üñºÔ∏è SELECCI√ìN Y ENV√çO DE IMAGEN ALEATORIA
        # ======================================

        # Buscar todas las im√°genes en el dataset
        image_extensions = ['.jpg', '.jpeg', '.png', '.bmp', '.gif']
        image_files = []

        for root, dirs, files in os.walk(path):
            for file in files:
                if any(file.lower().endswith(ext) for ext in image_extensions):
                    image_files.append(os.path.join(root, file))

        if image_files:
            # Seleccionar imagen aleatoria
            selected_image_path = random.choice(image_files)

            # Enviar la imagen al usuario
            with open(selected_image_path, 'rb') as img_file:
                await context.bot.send_photo(
                    chat_id=update.effective_chat.id,
                    photo=InputFile(img_file),
                    caption="üé® *Imagen de referencia seleccionada para ti*\n\n"
                           "Esta imagen ha sido elegida basada en tus preferencias. "
                           "A continuaci√≥n analizaremos sus caracter√≠sticas...",
                    parse_mode=ParseMode.MARKDOWN
                )

            # Guardar la ruta de la imagen en user_data para referencia
            context.user_data['selected_image_path'] = selected_image_path

        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="‚ö†Ô∏è *No se encontraron im√°genes en el dataset*",
                parse_mode=ParseMode.MARKDOWN
            )

        # ======================================
        # ü§ñ GENERACI√ìN DE AN√ÅLISIS CON GEMINI
        # ======================================

        # Construir descripci√≥n del tatuaje basado en los datos del usuario
        user_data = context.user_data
        tattoo_description = (
            f"Categor√≠a: {user_data.get('categoria_tatuaje', 'No especificada')}, "
            f"Estilo: {user_data.get('estilo', 'No especificado')}, "
            f"Tem√°tica: {user_data.get('tematica', 'No especificada')}, "
            f"Ubicaci√≥n: {user_data.get('ubicacion', 'No especificada')}, "
            f"Tama√±o: {user_data.get('atributos_claves', 'No especificado')}"
        )

        # Generar contenido con Gemini
        prompt = f"""
                  <Rol>Eres un ANALISTA ESPECIALIZADO EN IDENTIFICACI√ìN DE ESTILOS DE TATUAJE.
                  Tu √∫nica funci√≥n es analizar tattoos y categorizar exactamente su estilo
                  y otras caracteristicas relacionadas al tatuaje.<Rol>

                  <Analisis>
                  1. IDENTIFICAR TEMA PRINCIPAL:
                  - Breve descripci√≥n de la imagen
                  - Parte del cuerpo que se encuentra en la imagen

                  2. ANALIZAR CARACTER√çSTICAS VISUALES:
                  - Paleta de colores (Color o Blanco y Negro)
                  - Grosor de l√≠neas
                  - Tipo de sombreado
                  - Nivel de detalle

                  3. CLASIFICAR ESTILO:
                  - Estilo principal (80% del dise√±o entre:Realismo, Tribal, Minimalista, old School,Geom√©trico)
                  - Influencias secundarias
                  - T√©cnicas mixtas si aplica

                  4. RECOMENDACIONES:
                  - Explicar porque es una buena opcion realizarce ese tatuaje, para hombre y para mujer
                  - Realizar un precio estimando segun {description_df}
                  <Analisis>

                  <Reglas>
                  - Explicar todo en espa√±ol
                  - Ser claro y conciso
                  - Incluir emojis relevantes
                  - M√°ximo 500 palabras
                  <Reglas>

                  <Preferencias del usuario>
                  estas son las Preferencias del uruario {tattoo_description} encontrar  {description_df}
                  <Preferencias del usuario>
                  """

        response = model.generate_content(prompt)

        # Enviar recomendaciones al usuario
        recommendations = response.text

        # Dividir el mensaje si es muy largo (l√≠mite de Telegram: 4096 caracteres)
        if len(recommendations) > 4000:
            parts = [recommendations[i:i+4000] for i in range(0, len(recommendations), 4000)]
            for part in parts:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=part,
                    parse_mode=ParseMode.MARKDOWN
                )
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=recommendations,
                parse_mode=ParseMode.MARKDOWN
            )

        # Guardar las recomendaciones en user_data para referencia
        context.user_data['ia_recommendations'] = recommendations

        # Continuar con el flujo pidiendo el email
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="‚ú® *¬°Recomendaciones generadas!*\n\n"
                 "Si deseas que uno de nuestros artistas te contacte para discutir estas ideas, "
                 "por favor ingresa tu *correo electr√≥nico*:",
            parse_mode=ParseMode.MARKDOWN
        )

        return EMAIL

    except Exception as e:
        print(f"Error en IA: {e}")

        # En caso de error, continuar con el flujo normal
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="‚ö†Ô∏è *No pudimos generar recomendaciones en este momento, pero podemos continuar.*\n\n"
                 "Si deseas que uno de nuestros artistas te contacte, "
                 "por favor ingresa tu *correo electr√≥nico*:",
            parse_mode=ParseMode.MARKDOWN
        )
        return EMAIL

# ======================================
# üîô FUNCI√ìN PARA RETROCEDER
# ======================================
async def back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # Get the previous state from the history
    if 'history' in context.user_data and len(context.user_data['history']) > 1:
        context.user_data['history'].pop()  # Remove current state
        previous_state = context.user_data['history'][-1] # Get previous state

        # Resend the message for the previous state
        if previous_state == EXISTENCIA:
            await start(update, context)
            return EXISTENCIA
        elif previous_state == MOTIVO:
            keyboard = [
                [InlineKeyboardButton("üñãÔ∏è Nuevo Tatuaje", callback_data="nuevo_tatuaje")],
                [InlineKeyboardButton("ü©π Correcci√≥n de Tatuaje", callback_data="correccion_tatuaje")],
                [InlineKeyboardButton("üéì Cursos", callback_data="cursos")],
                [InlineKeyboardButton("üéâ Eventos", callback_data="eventos")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "Gracias. ¬øCu√°l es el *motivo* de tu visita hoy?",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return MOTIVO
        elif previous_state == CATEGORIA_TATUAJE:
            keyboard = [
                [InlineKeyboardButton("1Ô∏è‚É£ Realista", callback_data="realista")],
                [InlineKeyboardButton("2Ô∏è‚É£ Minimalista", callback_data="minimalista")],
                [InlineKeyboardButton("3Ô∏è‚É£ Tradicional", callback_data="tradicional")],
                [InlineKeyboardButton("4Ô∏è‚É£ Lettering", callback_data="lettering")],
                [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "Perfecto üòé ¬°Vamos a crear algo incre√≠ble juntos!\n\n"
                "Selecciona la *categor√≠a* del tatuaje que te gustar√≠a realizarte:",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return CATEGORIA_TATUAJE
        elif previous_state == ESTILO:
            keyboard = [
                [InlineKeyboardButton("‚ö´ Sombras", callback_data="sombras")],
                [InlineKeyboardButton("„Ä∞Ô∏è L√≠neas", callback_data="lineas")],
                [InlineKeyboardButton("oth Otros", callback_data="otros_estilo")],
                [InlineKeyboardButton("‚ùì No s√©", callback_data="no_se_estilo")],
                [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                f"Excelente elecci√≥n üòç Has elegido un tatuaje de la categor√≠a *{context.user_data.get('categoria_tatuaje', 'No especificada')}*.\n\n"
                "¬øQu√© *estilo* de sombras o l√≠neas prefieres?", # Added text option
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return ESTILO
        elif previous_state == TEMATICA:
            keyboard = [
                [InlineKeyboardButton("ü¶Å Animales", callback_data="animales")],
                [InlineKeyboardButton("üå≥ Naturaleza", callback_data="naturaleza")],
                [InlineKeyboardButton("‚öõÔ∏è S√≠mbolos", callback_data="simbolos")],
                [InlineKeyboardButton("‚ùì No s√©", callback_data="no_se_tematica")],
                [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                f"Perfecto üëå Has seleccionado el estilo *{context.user_data.get('estilo', 'No especificado')}*.\n\n"
                "¬øCu√°l *tem√°tica* te gustar√≠a para tu tatuaje?\n\n_(O puedes escribir tu preferencia)_",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return TEMATICA
        elif previous_state == UBICACION:
            await query.edit_message_text(
                f"Interesante! Has elegido la tem√°tica *{context.user_data.get('tematica', 'No especificada')}*.\n\n"
                "¬øEn qu√© parte del cuerpo te gustar√≠a hacerlo? (Por ejemplo: brazo, pierna, espalda, etc.)\n\n"
                "_(Responde con texto)_"
            )
            return UBICACION
        elif previous_state == ATRIBUTOS_CLAVES:
            keyboard = [
                [InlineKeyboardButton("üìè Peque√±o", callback_data="pequeno")],
                [InlineKeyboardButton("üìê Mediano", callback_data="mediano")],
                [InlineKeyboardButton("üñºÔ∏è Grande", callback_data="grande")],
                [InlineKeyboardButton("‚ùì No s√©", callback_data="no_se_tamano")],
                [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                f"Ubicaci√≥n registrada: *{context.user_data.get('ubicacion', 'No especificada')}* üìç\n\n"
                "Genial üí™ ¬øQu√© *tama√±o* prefieres para tu tatuaje?",
                 parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return ATRIBUTOS_CLAVES
        elif previous_state == IA:
            keyboard = [
                [InlineKeyboardButton("ü§ñ S√≠, generar recomendaciones IA", callback_data="si_ia")],
                [InlineKeyboardButton("‚è≠Ô∏è Saltar al contacto", callback_data="no_ia")],
                [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "üé® *¬øTe gustar√≠a recibir recomendaciones personalizadas con IA?*\n\n"
                "Nuestra inteligencia artificial puede generar ideas √∫nicas basadas en tus preferencias "
                "y proporcionar estimados de precio y tiempo.",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            return IA
        elif previous_state == EMAIL:
            await query.edit_message_text(
                "‚ú® *¬°Recomendaciones generadas!* (o saltaste la IA)\n\n"
                "Si deseas que uno de nuestros artistas te contacte para discutir estas ideas, "
                "por favor ingresa tu *correo electr√≥nico*:",
                parse_mode=ParseMode.MARKDOWN
            )
            return EMAIL
        elif previous_state == PHONE:
            await query.edit_message_text(
                "Gracias. Ahora, por favor, comparte tu *n√∫mero de tel√©fono*:",
                parse_mode=ParseMode.MARKDOWN
            )
            return PHONE

    # If no history or only one state in history, stay in the current state
    return context.user_data.get('history', [EXISTENCIA])[-1]


# ======================================
# üèÅ INICIO /START
# ======================================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Clear user data on new start and initialize history
    context.user_data.clear()
    context.user_data['history'] = [EXISTENCIA] # Initialize history

    keyboard = [
        [InlineKeyboardButton("‚úÖ Ya he visitado Find Ink", callback_data="existente")],
        [InlineKeyboardButton("üÜï Soy nuevo en Find Ink", callback_data="nuevo")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "¬°Hola üëã! Bienvenido(a) a *Find Ink Tattoo Studio* üé®\n\n"
        "¬øYa has visitado nuestro estudio antes o eres nuevo(a)?",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )

    return EXISTENCIA

# Funci√≥n separada para manejar las opciones del bot√≥n
async def handle_option(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    opcion = query.data

    if opcion == "nuevo":
        # Aqu√≠ puedes agregar la l√≥gica para usuarios nuevos
        await query.edit_message_text(
            "¬°Bienvenido nuevo usuario! Estamos encantados de tenerte en Find Ink Tattoo Studio üé®\n\n"
            "¬øEn qu√© podemos ayudarte hoy?",
            parse_mode=ParseMode.MARKDOWN
        )
        return ConversationHandler.END

    elif opcion == "existente":
        await query.edit_message_text(
            "üéì *Cursos Find Ink*\n\n"
            "¬°Excelente elecci√≥n! üòé Ofrecemos cursos profesionales para artistas del tatuaje.\n\n"
            "üëâ Instagram: https://www.instagram.com/findink.co/\n"
            "üëâ skincode: https://uncognoscible-paler-nicola.ngrok-free.dev/"
            "üëâ Linktree: https://linktr.ee/findink.co",
            parse_mode=ParseMode.MARKDOWN
        )
        return ConversationHandler.END


# ======================================
# üí¨ EXISTENCIA DEL USUARIO
# ======================================
async def existencia(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    context.user_data["existencia"] = query.data
    context.user_data['history'].append(MOTIVO) # Add to history

    keyboard = [
        [InlineKeyboardButton("üñãÔ∏è Nuevo Tatuaje", callback_data="nuevo_tatuaje")],
        [InlineKeyboardButton("ü©π Correcci√≥n de Tatuaje", callback_data="correccion_tatuaje")],
        [InlineKeyboardButton("üéì Cursos", callback_data="cursos")],
        [InlineKeyboardButton("üéâ Eventos", callback_data="eventos")],
        # No back button on the first step
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        "Gracias. ¬øCu√°l es el *motivo* de tu visita hoy?",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    return MOTIVO

# ======================================
# üí¨ MOTIVO DE VISITA
# ======================================
async def motivo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    opcion = query.data
    context.user_data["motivo"] = opcion
    context.user_data['history'].append(CATEGORIA_TATUAJE) # Add to history

    if opcion == "nuevo_tatuaje" or opcion == "correccion_tatuaje":
        keyboard = [
            [InlineKeyboardButton("1Ô∏è‚É£ Realista", callback_data="realista")],
            [InlineKeyboardButton("2Ô∏è‚É£ Minimalista", callback_data="minimalista")],
            [InlineKeyboardButton("3Ô∏è‚É£ Tradicional", callback_data="tradicional")],
            [InlineKeyboardButton("4Ô∏è‚É£ Lettering", callback_data="lettering")],
            [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "Perfecto üòé ¬°Vamos a crear algo incre√≠ble juntos!\n\n"
            "Selecciona la *categor√≠a* del tatuaje que te gustar√≠a realizarte:",
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
        return CATEGORIA_TATUAJE

    elif opcion == "cursos":
        await query.edit_message_text(
            "üéì *Cursos Find Ink*\n\n"
            "¬°Excelente elecci√≥n! üòé Ofrecemos cursos profesionales para artistas del tatuaje.\n\n"
            "üëâ Instagram: https://www.instagram.com/findink.co/\n"
            "üëâ skincode: https://uncognoscible-paler-nicola.ngrok-free.dev/"
            "üëâ Linktree: https://linktr.ee/findink.co",
            parse_mode=ParseMode.MARKDOWN
        )
        return ConversationHandler.END


    elif opcion == "eventos":
        await query.edit_message_text(
            "üéâ *Eventos Find Ink*\n\n"
            "¬°Genial! üéä Nos encanta compartir el arte del tatuaje con la comunidad.\n\n"
            "üëâ Pr√≥ximos eventos:\n"
            "üîó https://linktr.ee/findink.co",
            parse_mode=ParseMode.MARKDOWN
        )
        return ConversationHandler.END

# ======================================
# üé® CATEGORIA DEL TATUAJE
# ======================================
async def categoria_tatuaje(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    categoria_tat = query.data
    context.user_data["categoria_tatuaje"] = categoria_tat
    context.user_data['history'].append(ESTILO) # Add to history

    keyboard = [
        [InlineKeyboardButton("‚ö´ Sombras", callback_data="sombras")],
        [InlineKeyboardButton("„Ä∞Ô∏è L√≠neas", callback_data="lineas")],
        [InlineKeyboardButton("‚ùì No s√©", callback_data="no_se_estilo")],
        [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        f"Excelente elecci√≥n üòç Has elegido un tatuaje de la categor√≠a *{categoria_tat}*.\n\n"
        "¬øQu√© *estilo* de sombras o l√≠neas prefieres?\n\n_(O puedes escribir tu preferencia)_", # Added text option
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    return ESTILO

# ======================================
# üñºÔ∏è ESTILO DEL TATUAJE (MODIFIED)
# ======================================
async def estilo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Check if it's a callback query (button click) or a text message
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        estilo_tat = query.data
        message_to_edit = query.edit_message_text
    elif update.message:
        estilo_tat = update.message.text
        message_to_edit = update.message.reply_text # Use reply_text for text messages
    else:
        # Should not happen, but handle if needed
        return ESTILO # Stay in the same state if input is neither callback nor text

    context.user_data["estilo"] = estilo_tat
    context.user_data['history'].append(TEMATICA) # Add to history

    keyboard = [
        [InlineKeyboardButton("ü¶Å Animales", callback_data="animales")],
        [InlineKeyboardButton("üå≥ Naturaleza", callback_data="naturaleza")],
        [InlineKeyboardButton("‚öõÔ∏è S√≠mbolos", callback_data="simbolos")],
        [InlineKeyboardButton("‚ùì No s√©", callback_data="no_se_tematica")],
        [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await message_to_edit( # Use the appropriate method (edit_message_text or reply_text)
        f"Perfecto üëå Has seleccionado el estilo *{estilo_tat}*.\n\n"
        "¬øCu√°l *tem√°tica* te gustar√≠a para tu tatuaje?\n\n_(O puedes escribir tu preferencia)_", # Added text option
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    return TEMATICA

# ======================================
# üåø TEMATICA DEL TATUAJE (MODIFIED)
# ======================================
async def tematica(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Check if it's a callback query (button click) or a text message
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        tematica_tat = query.data
        message_to_edit = query.edit_message_text
    elif update.message:
        tematica_tat = update.message.text
        message_to_edit = update.message.reply_text # Use reply_text for text messages
    else:
        # Should not happen, but handle if needed
        return TEMATICA # Stay in the same state if input is neither callback nor text

    context.user_data["tematica"] = tematica_tat
    context.user_data['history'].append(UBICACION) # Add to history

    await message_to_edit( # Use the appropriate method (edit_message_text or reply_text)
        f"Interesante! Has elegido la tem√°tica *{tematica_tat}*.\n\n"
        "¬øEn qu√© parte del cuerpo te gustar√≠a hacerlo? (Por ejemplo: brazo, pierna, espalda, etc.)\n\n"
        "_(Responde con texto)_"
    )
    return UBICACION

# ======================================
# üìç UBICACI√ìN DEL TATUAJE
# ======================================
async def ubicacion(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["ubicacion"] = update.message.text
    context.user_data['history'].append(ATRIBUTOS_CLAVES) # Add to history

    keyboard = [
        [InlineKeyboardButton("üìè Peque√±o", callback_data="pequeno")],
        [InlineKeyboardButton("üìê Mediano", callback_data="mediano")],
        [InlineKeyboardButton("üñºÔ∏è Grande", callback_data="grande")],
        [InlineKeyboardButton("‚ùì No s√©", callback_data="no_se_tamano")],
        [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "Genial üí™ ¬øQu√© *tama√±o* prefieres para tu tatuaje?",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN
    )
    return ATRIBUTOS_CLAVES

# ======================================
# üìê ATRIBUTOS CLAVES (Modificado para llamar a IA)
# ======================================
async def atributos_claves(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    context.user_data["atributos_claves"] = query.data
    context.user_data['history'].append(IA) # Add to history

    # Preguntar si quiere recomendaciones de IA
    keyboard = [
        [InlineKeyboardButton("ü§ñ S√≠, generar recomendaciones IA", callback_data="si_ia")],
        [InlineKeyboardButton("‚è≠Ô∏è Saltar al contacto", callback_data="no_ia")],
        [InlineKeyboardButton("üîô Atr√°s", callback_data="back")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        "üé® *¬øTe gustar√≠a recibir recomendaciones personalizadas con IA?*\n\n"
        "Nuestra inteligencia artificial puede generar ideas √∫nicas basadas en tus preferencias "
        "y proporcionar estimados de precio y tiempo.",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    return IA

# ======================================
# ü§ñ MANEJADOR DE OPCIONES IA
# ======================================
async def handle_ia_option(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    opcion = query.data

    if opcion == "si_ia":
        context.user_data['history'].append(EMAIL) # Add to history
        # Ir al estado de generaci√≥n IA
        return await ia_generation(update, context)
    elif opcion == "no_ia":
        context.user_data['history'].append(EMAIL) # Add to history
        # Saltar directamente a email
        await query.edit_message_text(
            "üëå Continuemos. Por favor, ingresa tu *correo electr√≥nico* "
            "para que nuestros artistas te contacten:",
            parse_mode=ParseMode.MARKDOWN
        )
        return EMAIL


# ======================================
# üìß RECEPCI√ìN DE CORREO ELECTR√ìNICO
# ======================================
async def email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['email'] = update.message.text
    context.user_data['history'].append(PHONE) # Add to history

    await update.message.reply_text(
        "Gracias. Ahora, por favor, comparte tu *n√∫mero de tel√©fono*:",
        parse_mode=ParseMode.MARKDOWN
    )
    return PHONE # Transition to PHONE state

# ======================================
# üì± RECEPCI√ìN DE N√öMERO DE TEL√âFONO
# ======================================
async def phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['phone'] = update.message.text
    context.user_data['history'].append(CONTACTO) # Add to history


    # Now transition to the final CONTACTO state
    await update.message.reply_text(
        "¬°Perfecto! Tus datos han sido registrados. üéâ\n\n"
        "Pronto nos pondremos en contacto contigo para continuar con tu proceso.\n\n"
        "Gracias por confiar en *Find Ink Tattoo Studio* üíÄüé®",
        parse_mode=ParseMode.MARKDOWN
    )
    print("üóÇÔ∏è Datos del cliente:", context.user_data)
    return ConversationHandler.END # End the conversation

async def main():
    app = ApplicationBuilder().token(API_TOKEN).build()

    flujo = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            EXISTENCIA: [CallbackQueryHandler(existencia)],
            MOTIVO: [CallbackQueryHandler(motivo)],
            CATEGORIA_TATUAJE: [CallbackQueryHandler(categoria_tatuaje)],
            ESTILO: [
                CallbackQueryHandler(estilo),
                MessageHandler(filters.TEXT & ~filters.COMMAND, estilo) # Added text handler
            ],
            TEMATICA: [
                CallbackQueryHandler(tematica),
                MessageHandler(filters.TEXT & ~filters.COMMAND, tematica) # Added text handler
            ],
            UBICACION: [MessageHandler(filters.TEXT & ~filters.COMMAND, ubicacion)],
            ATRIBUTOS_CLAVES: [CallbackQueryHandler(atributos_claves)],
            IA: [CallbackQueryHandler(handle_ia_option)],  # Nuevo estado
            EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, email)],
            PHONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, phone)],
            CONTACTO: [CallbackQueryHandler(handle_option)],
        },
        fallbacks=[CallbackQueryHandler(back, pattern='^back$')], # Add fallback for 'back'
    )

    app.add_handler(flujo)
    print("‚úÖ Bot iniciado. Esperando mensajes...")
    await app.run_polling(poll_interval=3.0)

# ======================================
# üèÅ EJECUCI√ìN
# ======================================
try:
    asyncio.run(main())
except RuntimeError:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())